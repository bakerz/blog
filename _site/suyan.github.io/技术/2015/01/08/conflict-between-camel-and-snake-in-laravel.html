<h2 id="section">1. 定义关联模型</h2>

<p>在Laravel里面，我们可以通过定义以下Model来完成关联查询。</p>

<p>```php
class MyPost extends Eloquent {
    public function myPostInfo () {
        return $this-&gt;hasOne(‘MyPostInfo’);
    }
}</p>

<p>class MyPostInfo extends Eloquent {}
```</p>

<h2 id="section-1">2. 使用关联模型</h2>

<p>这里<code>myPostInfo()</code>用的是Camel命名规则，但是我们在读取某一个PostInfo的时候可以用Snake规则。如下面代码都是可行的：</p>

<p><code>php
$post = MyPost::find(1);
$post_info = $post-&gt;myPostInfo; // example 1
$post_info = $post-&gt;my_post_info; // example 2
</code></p>

<p>Laravel允许上述两种方法，但是没有合理的处理使用两种命名造成的冲突。</p>

<h2 id="section-2">3. 缓存失效</h2>

<p>如果我们同时使用了上述两个例子，就会使其中一个缓存失效。在Model的relations变量中，缓存了已经读取过的关联Model，但是当我们用不同规则的名字去读取的时候，却会使得前一个缓存失效。例如</p>

<p>```php
$post_info = $post-&gt;myPostInfo; 
// $post-&gt;relations = [‘myPostInfo’ =&gt; ..];</p>

<p>$post_info = $post-&gt;my_post_info;
// $post-&gt;relations = [‘myPostInfo’ =&gt; …, ‘my_post_info’ =&gt; …];
```</p>

<p>所以如果不希望缓存失效，得在项目中只使用一种命名方法去读取关系模型。Laravel推荐的是Camel Case.</p>

<h2 id="toarray-">4. toArray() 方法失效</h2>

<p>如果同时使用了两者，另外一个问题就是导致<code>Model::toArray()</code>失效。因为<code>toArray()</code>方法首先去<code>relations</code>中查找Snake Case命名的关联模型，没有的话才去看Camel Case的。</p>

<p>所以如果用到了<code>toArray()</code>方法来转换Model，切忌同时使用两者。</p>

<h2 id="section-3">5. 容易犯错的位置</h2>

<p>最容易犯错的代码是这样的：</p>

<p><code>php
MyPost::with(‘myPostInfo’)-&gt;get();
</code></p>

<p>在使用With去eagerLoad关联模型时，必须使用和定义方法同名的key去读取，那么这样读取出来的方法只能是Camel Case的key。其他地方就只能用</p>

<p><code>php
$my_post-&gt;myPostInfo;
</code></p>

<p>来保证不出问题。</p>
